spring.application.name=dosa_backend

# Load local .env as a properties source (optional)
# spring.config.import=optional:file:.env.local[.properties]

server.port=${SERVER_PORT:8080}

# PostgreSQL
spring.datasource.url=${DB_URL:}
spring.datasource.username=${DB_USER:}
spring.datasource.password=${DB_PASSWORD:}
spring.datasource.driver-class-name=org.postgresql.Driver

spring.jpa.hibernate.ddl-auto=update
spring.jpa.open-in-view=false
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.format_sql=true

# Storage
app.storage.base-dir=${STORAGE_DIR:./storage}


# OpenAI (NEVER hardcode keys here)
openai.api-key=${OPENAI_API_KEY:}
openai.base-url=${OPENAI_BASE_URL:https://api.openai.com/v1}

# Models
openai.chat-model=${OPENAI_CHAT_MODEL:gpt-5-mini}
openai.embedding-model=${OPENAI_EMBEDDING_MODEL:text-embedding-3-small}

# Optional: shrink embeddings dimension to reduce DB size (0 = provider default)
openai.embedding-dimensions=${OPENAI_EMBEDDING_DIMENSIONS:0}

# Responses API token budgets
# - 크게 잡으면 incomplete(max_output_tokens) 재시도가 줄어듦
# - 대신 응답 지연/비용이 증가할 수 있으니 운영환경에서는 관측 후 조정 권장
openai.responses.max-output-tokens=${OPENAI_RESPONSES_MAX_OUTPUT_TOKENS:800}
openai.responses.retry-max-output-tokens=${OPENAI_RESPONSES_RETRY_MAX_OUTPUT_TOKENS:1000}

# Reasoning effort: low/medium/high (서비스 요구에 맞게)
openai.responses.reasoning-effort=${OPENAI_RESPONSES_REASONING_EFFORT:low}

# (옵션) Chat Completions API를 쓰는 코드가 남아있다면 유지
openai.chat.max-completion-tokens=${OPENAI_CHAT_MAX_COMPLETION_TOKENS:1000}

# Chat system prompts (wired from .env)
app.chat.root-system-prompt=${APP_CHAT_ROOT_SYSTEM_PROMPT:당신은 과학 공학 학습용 3D 뷰어 서비스의 AI 튜터다. 멀티턴 대화에서 최근 대화 기록을 우선 참조하고 이전 턴의 질문 의도와 가정을 이어서 답하라. metadata의 model은 modelId와 title만 사용하고 parts는 partId displayNameKo summary를 핵심 근거로 사용하라. 없는 정보는 추측하지 말고 부족한 정보를 명확히 말한 뒤 필요한 확인 질문을 1개 제시하라. 사용자가 그거 이 부품 방금 같은 지시어를 쓰면 대화 기록에서 지시 대상을 복원해 답하라. 각 부품의 역할과 인과관계를 설명할 때는 parts 메타데이터를 활용해 조립 구조 관점에서 단계적으로 연결하라. 최대한 이해하기 쉽고 간결하게 명확히 설명하라. 반드시 최대한 요약하고 최소화해서 설명하라.}
app.chat.model-system-prompts.v4_engine=${APP_CHAT_MODEL_V4_ENGINE_SYSTEM_PROMPT:V4 엔진은 연소 압력이 피스톤의 왕복 운동을 만들고 커넥팅 로드를 통해 크랭크샤프트 회전으로 변환되는 토크 전달 사슬을 중심으로 설명하라. parts에 포함된 partId displayNameKo summary를 이용해 해당 부품의 역할을 연결해서 설명하고 부품 간 인과관계를 단계적으로 정리하라. 질문이 정비 진단 비교로 이어지면 이전 턴의 결론을 유지한 채 원인 후보와 확인 포인트를 구분해 제시하라.}
app.chat.model-system-prompts.suspension=${APP_CHAT_MODEL_SUSPENSION_SYSTEM_PROMPT:서스펜션은 하중 이동과 감쇠를 통해 접지력과 승차감을 동시에 관리하는 시스템으로 설명하라. 스프링 저장 에너지와 댐퍼 감쇠 작용을 분리해 설명하고 parts 메타데이터의 부품 역할을 조립 구조 관점으로 연결하라. 멀티턴에서는 이전에 다룬 노면 조건 속도 하중 조건을 유지해 동일 조건 비교 답변을 제공하라.}
app.chat.model-system-prompts.robot_gripper=${APP_CHAT_MODEL_ROBOT_GRIPPER_SYSTEM_PROMPT:로봇 그리퍼는 구동 기어 링크 전달 파지 접촉 마찰의 순서로 설명하라. parts의 partId displayNameKo summary를 사용해 각 링크와 그리퍼가 어떻게 힘을 전달하는지 좌우 대칭 관계까지 명확히 설명하라. 멀티턴에서는 사용자가 제시한 물체 특성 무게 표면 마찰을 계속 기억해 파지 전략을 업데이트하라.}
app.chat.model-system-prompts.drone=${APP_CHAT_MODEL_DRONE_SYSTEM_PROMPT:드론은 추력 분배 자세 제어 안정화 루프의 관점에서 설명하라. 프레임 모터 프로펠러 역할을 분리하고 parts 메타데이터의 부품 정보를 이용해 힘 경로와 진동 영향까지 연결하라. 멀티턴에서는 이전 턴의 비행 조건 바람 하중 배터리 상태를 이어 받아 제어 관점의 차이를 비교하라.}
app.chat.model-system-prompts.robot_arm=${APP_CHAT_MODEL_ROBOT_ARM_SYSTEM_PROMPT:로봇 암은 링크 조인트 직렬 체인 관점에서 자유도 작업좌표계 역기구학 특이점 위험을 포함해 설명하라. parts의 partId displayNameKo summary를 사용해 베이스에서 엔드이펙터까지 운동 전달을 순서대로 연결하라. 멀티턴에서는 이전 턴에서 확정한 좌표계 기준과 목표 자세를 유지해 단계별로 해법을 일관되게 이어가라.}

# swagger
springdoc.api-docs.path=/v3/api-docs
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.swagger-ui.enabled=true
springdoc.swagger-ui.operations-sorter=method
springdoc.swagger-ui.tagsSorter=alpha
springdoc.packages-to-scan=com.test.dosa_backend.controller

# Logging
logging.level.org.hibernate.SQL=INFO

# File upload limits (PDF ingest)
spring.servlet.multipart.max-file-size=${APP_UPLOAD_MAX_FILE_SIZE:50MB}
spring.servlet.multipart.max-request-size=${APP_UPLOAD_MAX_REQUEST_SIZE:50MB}
server.tomcat.max-swallow-size=${APP_UPLOAD_TOMCAT_MAX_SWALLOW_SIZE:60MB}
server.tomcat.max-http-form-post-size=${APP_UPLOAD_TOMCAT_MAX_FORM_SIZE:60MB}
